# **Linux 系统编程笔记**
## **Linux C 编程环境**

Linux系统下一般使用 C 语言编写系统程序以及对性能有较高要求的程序

Linux 环境通常使用 gcc 套件编译程序，运用gdb/ddd 调试工具进行程序的调试和排错。Windows 系统的开发环境(如 Visual Studio 2018)一般可将这两种功能集成在-起使用，Linux虽然也有一些这样的集成开发环境，如Eclipse，但很多熟练的程序员喜欢直接用 gcc 命令行工具进行开发，这样编程效率更高，接下来介绍用Linux环境中的 gcc 开发套件对程序进行编译、调试、排错和项目管理的基本方法，是Linux 环境下使用C/C++进行系统编程和应用编程开发的基础，其中涉及的方法和原理也适用于 Windows 等非 Linux 的环境

### **一、Linux C 程序的编译与执行**

首先创建一个 hello.c，运行 `gcc hello.c`，再用 ls -l 列出当前目录下的文件，会发现生成了一个 a.out 程序，这就是执行 gcc 命令后产生的可执行文件，./a.out 可以执行该程序，gcc 是 Linux 环境下的 C 语言编译器，gcc 命令的用法 `gcc 选项 文件名称`，gcc 命令选项多达 100 个，gcc 将源程序转换成可执行文件需要经历预处理、编译、汇编以及链接四个过程

**预处理**

带命令选项 -E 的 gcc 命令调用预处理程序 cpp，扫描源代码，检查其中的宏定义与预处理命令，执行宏替换，展开包含文件，删除程序中的注释以及多余的空白字符，-o 可以指定处理后的文件名称，预处理的输出文件一般以 .i 为后缀

* gcc 使用 -E 参数，将 hello.c 预处理成 hello.i
* 展开宏、头文件，替换条件编译，删除注释、空行、空白

**编译**

带命令选项 -S 的 gcc 命令调用编译程序 ccl 对 .c 或 .i 源程序进行编译，产生汇编语言代码，用 -o选项指定汇编代码文件名，编译的输出文件一般以 .s 为后缀

* gcc 使用 -S 参数，将 hello.i 编译成 hello.s
* 检查语法规范，并将 C 代码翻译成汇编代码(消耗时间在、系统资源最多)

**汇编**

带命令选项 -c 的 gcc 命令调用汇编程序 as，将汇编代码汇编成目标机器指令，它生成与源程序同名的.o目标代码文件，使用 -c 选项表示让 gcc 仅完成前三步，即可实现对源代码的预编译、编译和汇编

* gcc 使用 -c 参数，将 hello.s 汇编成 hello.o
* 将汇编指令翻译成机器指令

**链接**

不带 -S、-c、-E 选项的 gcc 命令将根据需要，执行预处理、编译、汇编，并调用链接程序 collect2，将一个或多个目标代码文件与相关库文件链接起来，产生可执行文件

* gcc 不使用 -E 、-S、-c 参数，将 hello.o 链接成 a.out
* 数据段合并，地址回填

**使用头文件和库文件**

在软件开发过程中，经常会使用外部或其他模块提供的功能，这些功能一般以库文件的形式提供，比如输入输出要调用 IO 库函数,开发图形用户界面需要使用图形库，开发动画程序需要使用 OpenGL 库，从摄像头采集视频需要调用视频库。未来开发应用时，几乎都不可避免要使用某种库文件(又称函数库)，这些库文件提供的函数又称API函数

函数库是由一些提供公共功能的函数、代码、变量定义的二进制代码文件，可被各种应用程序调用，链接到它们的可执行程序中。函数库里有 Linux 系统自带库函数、第三方库函数和用户自定义库函数，都有相应的库文件，Linux 自带的库文件有数十个之多，一般用到哪个就加载哪个，为此需要在gcc命令中用 -l 选项指明函数库名称。比如，如果要链接库文件 lib库名.so 或 lib库名.a,则 gcc 命令要增加选项 -l库名

gcc 默认使用共享库文件，如果要使用静态库，则应增加 -Bstatic 选项。由于大多数程序都要调用 scanf、printf、 fread、 fwrite 等库函数，gcc 在默认情况下自动将系统 I/O 库 libc.so 链接到可执行文件,因此不需要用链接选项 -lc 指明使用I/O库文件名libc.a或libc.so。因此，在前面的“gcc hello.c"命令中就没有使用 -l 选项。但如果调用了其他种类的库函数，如数学运算、线程管理函数,就必须用 -l 选项指定库文件名

为让调用库函数的程序能正确编译链接和执行，需要做三件事情

1. 包含库函数头文件

   * 源文件应包含库文件的原型、相关类型定义的头文件，避免函数的隐式声明

   * 如果不知道系统中库函数的头文件名称，可以使用 man 命令查询函数使用说明

   * 如果需调用第三方 API 库函数，可从相关厂商取得对应头文件

   * 即便是用户定义库函数，程序员也应创建相关头文件

2. 链接时指明库文件

   * 在 gcc 链接命令中用选项 -l (link) 指明包含 API 或库函数代码实现的库文件

   * 库文件一般是由多个 .o 文件打包而成的文件，按照库文件加载时机的不同，有静态库及动态库(或共享库)两种形式

   * 库是写好的现有的，成熟的，可以复用的代码，现实中每个程序都要依赖很多基础的底层库，本质上来说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行,库有两种分别是静态库(.a、.lib)和动态库(.so、.dll)，所谓静态、动态是指链接的方式不同

   * **静态库**

     * 在链接阶段，会将汇编生成的目标文件 .o 与引用到的库一起链接打包到可执行文件中，对应的链接方式称为静态链接，静态库与汇编生成的目标文件一起链接为可执行文件，其实一个静态库可以简单看成是一组目标文件（.o/.obj文件）的集合，即很多目标文件经过压缩打包后形成的一个文件
	  * 当用选项 -Bstatic 指明采用静态链接时，gcc 将静态库代码复制到每一个可执行文件中，随着程序启动而加载到内存中。Linux 静态库以 .a 为文件名后缀，对于名为 name 的静态库，文件名命名规范一般为 libname.a
	  
	 * **动态库**
	
	   * 动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入，不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题，也解决了静态库对程序的更新、部署和发布页会带来麻烦，用户只需要更新动态库即可，增量更新
	
	     * 当采用动态链接时，gcc 仅将动态库的链接信息写到可执行文件中，不复制库函数代码，生成的可执行文件比较小，动态库仅当程序运行过程中实际调用库中的函数时才加载到内存中
	
	     * 动态库又称共享库，仅在内存中保存一个副本，为多个应用程序共用，节省内存用量。当动态库修正错误或更新升级时，只要调用接口不变，使用它的源程序就不需要重新编译。动态库的文件名后缀为 .so,对于名为 name 的动态库，文件命名规范一般为 libname.so

3. 链接时指定头文件和库文件所在路径
   * 有时需要用 -I 选项和 -L 选项分别指定第三方库函数的头文件和库文件所在目录
   * -Idir 选项(Include) gcc 命令搜索头文件的默认目录，一般是 /usr/include
     * 如果被搜索的头文件位于其他目录下，则使用-I选项将该目录增加到搜索头文件的路径中，若涉及的文件在当前目录下，则gcc命令应有选项 `I.` 
     * 由于用引号指明的头文件规定仅在当前目录下搜索，因此写成代码行`#include "wrapper.h"` 时就不需要 `-I.` 选项
   * -Ldir 选项(L是单词Link的首字母) 通常 gcc 生成可执行文件所需的系统库文件位于默认目录
     /us/lib下，如果所需的库文件位于其他目录下，则使用-L将该目录添加到库文件的搜索路径中，若所需库文件在当前目录下，则编译命令中应加入选项“L.”

**使用 gcc 创建自定义库文件**

尽管很多情况下只需要调用已有的库函数,但有时也编写一些函数模块供他人使用，或作为 API 库发布给开发者，这时可以创建自己的库文件

1. **静态库文件**的创建和使用

   * 首先将其**编译**为目标文件
     * `gcc -c 源文件 -o 目标文件.o` 
   * 然后使用 ar 命令 **生成静态库文件** lib静态库文件名.a
   
     * `ar rc lib静态库文件名.a 目标文件.o 目标文件.o` 
     * 名称必须以 lib 开头，后缀必须为 .a
     * 参数 r 用来替换库中已有的目标文件，或者加入新的目标文件
     * 参数 c 表示创建一个库。不管库否存在，都将创建
     * 可加上参数 s 用来创建目标文件索引，这在创建较大的库时能提高速度
   * 最后在**链接**阶段加上 -Bstatic 选项静态链接，

     * `gcc 源文件 -Bstatic -L 静态库目录 -l 静态库名 -o 可执行程序名称` 
     * 直接使用静态库名时，可以加上 -Bstatic 选项强制 gcc 使用静态库链接
     * `gcc 源文件 -L 静态库路径 -l 静态库名 -o 可执行程序名称` 
     * 不加 -Bstatic 参数也可以进行静态链接
     * 因为自制库文件的目录非默认的库文件搜索路径中，因此必须用 -L 选项添加到库文件搜索路径中，选项 -l 指定库文件，-o 指定可执行程序名称

2. **动态库文件**的创建和使用

   * 首先使用命令生成源文件的目标文件，在使用 -c 参数的 gcc的同时再加上 -fPIC 选项表示生成位置无关代码
     * `gcc -c -fPIC 源文件 -o 目标文件.o ...` 

   * 再通过以下命令创建共享库
     * `gcc -shared -o lib动态库名.so 目标文件.o 目标文件.o ...` 

使用 ldd 命令可以查看程序运行时需要加载的动态库文件，由于链接的是动态库，需要在程序的执行过程中加载动态库，因此必须以某种方式将动态库所在目录路径告知加载程序，告知动态库的位置

* 共享库路径添加到环境变量中(临时生效)
  * `export LD_LIBRARY_PATH=dir`
* 写入终端配置文件(永久生效)
  * `vi ~/.bashrc`
  * 修改 `export LD_LIBRARY_PATH=dir`
  * `. .bashrc` 或 `source .bashrc` 使配置文件生效
  * `ldd 可执行程序` 查看运行时需要加载的动态库文件
* 拷贝自定义动态库到 /lib 目录下(不推荐)

* 将自定义动态库添加到 /etc/ld so.conf 文件中
  * `vi /etc/ld so.conf` 将路径写入配置文件
  * `ldconfig -v` 使配置文件生效
  * `ldd 可执行文件` 查看运行时需要加载的动态库文件

**静态库特点**

* 应用在对空间要求较低，而时间要求较高的核心程序中
* 静态库对函数库的链接是放在编译时期完成的
* 浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件

**动态库特点**

* 应用在对时间要求比较低，对空间要求较高的程序中
* 动态库把对一些库函数的链接载入推迟到程序运行的时期
* 可以实现进程之间的资源共享(因此动态库也称为共享库)
* 将一些程序升级变得简单
* 甚至可以真正做到链接载入完全由程序员在程序代码中控制(显示调用)

**动态加载库**

动态加载库和一般的动态链接库所不同的是，一般动态链接库在程序启动的时候就要寻找动态库，找到库函数。而动态加载库可以用程序的方法来控制什么时候加载，主要函数有 dlopen()、dlerror()、disym、dlclose()

1. 打开动态库 dlopen() 函数
   * 函数原型
     * `void* dlopen(const char *filename,int flag);`
   * 参数
     * filename 为动态链接库的文件名
     * flag 为打开方式，一般为 `RTLD_LASY`
     * 返回值为库的指针
2. 获得函数指针 dlsym() 函数
   * 函数原型
     * `void* dlsym(void *handle,char *symbol);`
   * 参数
     * handle 为 dlopen 打开动态库后返回的句柄
     * symbol 为函数的名称
     * 返回值为函数指针

**gcc 其他参数说明**

* -I 可以指定头文件所在目录位置
* -g 编译时添加调试文件
* -Wall 显示所有的警告信息
* -D 向程序中注册宏信息

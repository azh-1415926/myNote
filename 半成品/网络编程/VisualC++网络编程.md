# **Visual C++网络编程**
## **第 1 章 Visual C++ 网络开发基本应用**
### 1.1 获取网卡的类型和MAC地址
* 网卡的类型可以从注册表中获得
* MAC(Media Access Control)地址也称为硬件地址
### 1.1.1 Visual C++网络编程概述
Visual C++(VC)网络编程指用户使用MFC类库(微软基础库)在VC编译器中编写程序，以实现网络应用

用户通过VC编程实现的网络软件可以在网络中不同的计算机之间互传文件、图像等信息

在VC编译器中，使用Windows Socket进行网络程序开发是网络编程中非常重要的一部分

#### 1.网络基础知识
(1) TCP/IP

TCP/IP 协议实际上是一个协议簇，其中包含了很多协议

在数据传输层中，包含了TCP和UDP协议
* 其中TCP协议是基于面向连接的可靠的通信协议，具有重发机制，即当数据被破坏或者丢失时，发送方将重发该数据
* 而UDP协议是基于用户数据报协议，属于不可靠连接通信的协议，并没有重发机制

(2) C/S 编程模型

C/S 编程模型是基于可靠连接的通信模型

通信的双方必须使用各自的IP地址以及端口进行通信
当用户使用 C/S 编程模型进行通信，任意一方为客户端，则另一方为服务器端
服务器端等待客户端连接请求的到来，这个过程叫监听
通常服务器监听功能是在特定IP地址和端口上进行
然后客户端向服务器发送连接请求
服务器响应，则该请求连接成功
#### 2.网络编程基础
使用MFC中封装的套接字类来编写网络应用程序，也可以使用 Windows API函数进行程序开发

使用MFC相关类编程会使用户对网络通信中基本原理缺乏清晰的认识，而使用 Windows API函数可以使用户熟悉网络通信的基本原理

在实际编程过程中，通信双方的连接以及数据通信均是基于Socket套接字进行的

(1) Socket套接字

在Windows中编写网络通信程序时，需要使用Windows Sockets，相关的API函数称为Winsock函数

网络通信的双方均有各自的套接字，并且与特定的IP地址和端口相关联

通常套接字有两种类型，分别是流式套接字(SOCK_STREAM)、数据报套接字(SOCK_DGRAM)，且分别用在 TCP 和 UDP 协议通信的应用程序中

(2) 网络字节顺序

网络字节顺序指的是 TCP/IP 协议中规定的数据传输使用格式，与之对应的顺序是主机字节顺序

网络字节顺序表示首先将字节中重要的字节进行存储
例如，当数据0x358457 使用网络字节顺序进行存储时，该内存的存放顺序将是0x35、0x84、0x57

因为在通信数据可能会在不同机器之间进行传输，所以通信数据必须以相同的格式进行整理
只有经过格式处理的通信数据，才能在不同的机器之间进行传输

#### 3.网络通信基本流程

要通过互联网进行通信，用户至少需要一对套接字，其中一个运行于客户机端(ClientSocket)，另一个运行于服务器端(ServerSocket)

套接字之间的连接过程分为三个步骤，分别是服务器监听、客户端请求、连接确认

(1) 服务器监听:

服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态

(2) 客户端请求:

由客户端的套接字提出连接请求，要连接的目标是服务器端的套接字
* 客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务端套接字的地址和端口号，然后就向服务器套接字提出连接

(3) 连接确认:

当服务器端套接字监听到或者接收到客户端套接字的连接请求时，它就响应客户端套接字的请求，建立一个新的线程，把服务器套接字的描述发给客户端，一旦客户端确认了此描述，连接就建立好了

而服务器端套接字继续处于监听状态，继续接受其他套接字的连接请求

#### 4.搭建开发环境

在Visual C++环境下进行 Winsock 的API编程开发，需要在项目中导入以下三个文件
* WINSOCK.h : WINSOCK API 的头文件，需要包含在项目中
* WSOCK32.lib : WINSOCK API 链接库文件，使用时一定要把它作为项目的非默认的链接库包含到项目文件中去
* WINSOCK.dll : WINSOCK 的动态链接库，位于Windows 的安装目录下

#### 5.两个常用的数据结构

套接字是网络通信过程中端点的抽象表示，在实现中以句柄的形式创建，包含了进行网络通信所需的 5 种信息 : 连接使用的协议、本地主机的 IP 地址、本地进程的协议端口、远程主机的 IP 地址、远程进程的协议端口

WinSock 编程中常用的数据结构有 sockaddr_in 和 in_addr

(1) sockaddr_in 结构

WinSock 通过 sockaddr_in 结构对有关 Socket 的信息进行了封装
```c
struct sockaddr_in {
    short sin family;
    unsigned short sin_port;
    IN_ADDR sin_addr;
    char sin_zero[8];
}
```
* sin_family : 指网络中标识不同设备时使用的地址类型，对于 IP 地址，它的类型的 AF_INET
* sin_port : 指 Socket 对应的端口号
* sin_addr : 是一个结构，将 IP 进行了封装
* sin_zero : 一个用来填充结构的数组，字符全为 0 ，这个结构对于不同地址类型可以是相同的大小

(2)in_addr

in_addr 结构对 IP 地址进行了封装，既可以用 4 个单字节数表示，也可以转换为两个双字节数表示或一个四字节数表示
```c
struct in addr {
    union {
        struct { u_char s_b1,s_b2,s_b3,s_b4; }S_un_b;
        struct { u short s w1,s w2; }S un w;
        u long S addr;
    }S un;
}
```
#### 6.Windows Sockets基础

在 MFC 类库中，几乎封装了 Windows Sockets 的全部功能，接下来介绍两个最常用的套接字类 CAsyncSocket 类和 CSocket 类

(1) CAsyncSocket 类

在微软基础类库中，CAsuncSocket 类封装了异步套接字的基本功能

1)调用构造函数创建套接字对象

2)如果创建服务器端套接字，则调用函数 Bind()绑定本地 IP 和端口，然后调用函数 Listen()监听客户端的请求

如果请求到来，则调用函数 Accept() 响应该请求

如果创建客户端套接字，则直接调用 Connect() 连接服务器即可

3)调用 Send() 等功能函数进行数据传输与处理

4)关闭或销毁套接字对象

(2) CSocket 类

CSocket 类派生于 CAsyncSocket 类，该类不仅具有 CAsyncSocket 类的基本功能，还具有序列化功能

用户在实际编程中，通过将 CSocket 类与 CSocketFile 类和 CArchive 类一起使用，能够很好地管理数据以及发送数据

1)创建CSocket 对象

2)如果创建服务器端套接字，则调用函数 Bind() 绑定本地 IP 和端口，然后调用函数 Listen() 监听客户端的请求

如果请求到来，则调用函数 Accept() 响应该请求

如果创建客户端套接字，则直接调用函数 Connect() 连接服务器即可

3)创建与 CSocket 类对象相关联的 CSocketFile 类对象

4)创建与 CSocketFile 对象相关联的 CArchive 对象

5)使用CArchive 类对象在客户端和服务器之间进行数据传输

6)关闭或销毁 CSocket 类、CSocketFile 类、CArchive 类的 3 个对象
### 1.1.2 MAC 地址的原理
MAC 意为介质访问控制
MAC地址是烧录在网卡NIC(Network Interface Card)里的MAC地址，也叫硬件地址，是由 48 比特长(6 字节)十六进制的数字组成
其中 0-23 位叫做组织唯一标志符(Oranizationally Unique Identifier)，是识别 LAN(局域网)节点的标识
而 24-27 位是由厂家自己分配的
其中第 40位是组播地址标志位
网卡的物理地址通常是由网卡厂家烧入网卡的 ERPROM(一种闪存芯片)中，它存储的是传输数据时真正赖以标识发出数据的电脑和接收数据的主机的地址
在网络底层的物理传输过程中，通过物理地址来识别主机，它一般也是全球唯一的
### 1.1.3 NetBIOS 编程基础
NetBIOS 是用于网络的基本输入/输出系统，是一个应用程序接口，用于源与目的地之间的交换，即能够支持计算机应用程序与设备通信要所用到的各种明确而简单的通信协议，必须用特殊的命令序列来调用 NetBIOS

在参考层次模型中，NetBIOS 处于表示层和会话层之间，时参考模型的高层
它支持 IEEE802.2 的逻辑链路控制协议，现在正迅速成为不同系统环境下普遍使用的通信平台，如PC DOS、OS/2、Unix、Windows

#### 1.处理过程

(1)建立会话

NetBIOS 的 Client 方采用 Call 呼叫对方，而不是 Connect

(2)传输数据

因为 NetBIOS 的会话服务是以双工流的形式实现的，因此会话双方(或多方)均可以同时发送或接收数据，而无须考虑对方的状态

NetBIOS 的命令发送支持两种模式，一种是 send，其数据块最大长度为 64KB，且位于连续的内存空间，另一种则是 chain send命令，它是以多个缓冲区(两个)提供发送数据的，因此一次可最大传送 64KBx2 的数据，与此对应的 NetBIOS 接收命令如下
* receive : 它以建立会话时所获得的唯一标识对方的会话号为句柄接收数据
* receive any : 该命令可从一个 name 建立的多个会话上取得数据
* receive any-any : 它可从任何会话上接收任何数据
(3)终止会话

当会话一方发出 hang up 命令后，即可终止对话，并释放相应的资源
#### 2.NetBIOS 命令
NetBIOS 作为一种接口，拥有许多实现某些功能的接口
命令 | 功能说明 |
---  | --- 
add name | 增加本地唯一名
add group name | 增加本地小组名
delete name | 删除本地名字
send datagram | 发送数据报
send broadcast | 发送广播数据报
receive datagram | 接收数据报
receive broadcast | 接收广播数据报
call | 呼叫建立对话
listen |侦听建立对话
send | 按会话号发送数据
chain send | 按会话号发送双缓冲数据
send no-ack | 按会话号发送数据，不应答
chain send no-ack |  发送双缓冲数据，不应答
recevie | 按会话号接收数据
receive any | 从任意会话号上接收数据
hang up | 拆除当前会话
repeat | 初始化网络适配器
adapter status | 读取网络适配器状态
session status | 按名字读取当前会话状态
cancel | 撤销一个 NetBIOS 命令
unlink | 断开远程连接
#### 3.NetBIOS 名字解析
由于 NetBIOS 是一种与 TCP/IP 独立发展的标准，虽然它可以使用 TCP/IP 作为传输协议，但由于概念上的不同，它并没有利用 TCP/IP 的全部能力，而是使用自己的方式来完成类似的工作

NetBIOS 具备自己独立的名字解析概念和能力因此它使用的名字解析方式就与TCP/P中标准解析方式一DNS 不同

在必须经过NetBIOS名字解析获得相应的IP地址之后，NetBIOS 会话就可以建立在普通TCP连接的基础上了。所以在NetBIOS中，名字解析是NetBIOS会话与普通TCP连接最大的不同之处。
NetBIOS名字解析与DNS名字解析的最大不同在于NetBIOS是动态的，计算机需要首先注册自己的名字，然后才能解析到该名字。动态解析虽然带来很大的方便性，但却复杂和低效得多，因此只能用于小范围的局域网中。
每个NetBIOS的名字可以多达16个字符，第16个字符用来标识输入名字时使用的程序类型。当NetBIOS的计算机进行通信时，它必须基于NetBIOS名字，而不能基于IP地址。一个NetBIOS服务程序必须首先注册自己的NetBIOS名字，而一个应用程序则需要
查询所需要的NetBIOS 名字。例如，每台Windows 计算机在启动之后初始化网络时就使用所配置的计算机名字来初始化其使用的NetBIOS名字。
(1) NetBIOS 名字解析方式
从NetBIOS名字查找相应的节点地址(TCP/IP协议中为IP地址)有如下几种不同的查找方式
* 本地广播:在本地网络上发送广播，通过广播某设备的NetBIOS 名字，查找其对应的IP地址。广播方式也能用于注册自己的NetBIOS名字，例如，一台计算机可以通过广播本机的名字，向其他计算机宣告自己使用了这个NetBIOS名字
* 缓冲:每个支持NetBIOS的计算机中，维护一个NetBIOS名字和相应IP地址的列表，这些对应的名字都有-定的生存期，以便能及时更新
* NetBIOS名字服务器:使用一一个名字服务器来提供名字与IP之间的解析任务，这个NetBIOS名字服务器被称为NBNS(NetBIOS Name Server)， Microsoft 实现的NBNS名字服务器为WINS(Windows Interet Name Service)。 NetBIOS 计算机首先要向NBNS登记自己的NetBIOS名字，完成名字的注册过程
* 预定义文件lmhosts: Microsoft W indows能通过查找存放在本地文件lmhosts中的
数据，来识别网络上NetBIOS名字和IP的关系，这个方式不是NetBIOS名字识别的标准，但它是Microsoft的实现方式，因此是一种事实标准
* 通过DNS和hosts文件解析: DNS服务器和本地hosts文件中存放的数据是用于标准TCP/P协议中名字和IP之间转换使用的方式，但使用其他方式查找不出对应的节点地址时，Microsoft Windows中通常也能通过标准的TCP/IP名字解析方式，进行名字和IP的转换。同样这也不是NetBIOS的标准，而是Microsoft的
扩展

从上述5种NetBIOS识别方式，以及其中的不同的名字注册方式出发，可以实现不同的组合方式，从而构成了不同的名字识别策略。在NetBIOS标准中，将使用不同名字识别策略的模式称为不同的NetBIOS节点类型。

* B-node:通过广播方式来进行注册和识别NetBIOS名字。对于IP协议上的NetBIOS，就需要基于UDP进行广播，在小网络上这种方式工作得很好，但当网络增大时，就会被使用路由器将大网络分割为几个小网。在一般情况下路由器不转发广播数据，广播包仅发送到本地网络。虽然可以配置路由器进行b-node广播转发，但是这将使UDP广播产生大量的无用网络数据，且名字注册和解析的难度也增加了。因此对于较大的网络，这种方式不可取。
* P-node(peer-t-peer): 对等方式能为识别名字提供非常有效的方法，它使用NetBIOS名字服务器进行名字的注册登记和名字识别。因此对于每个NetBIOS计算机，必须指定同样的NBNS服务器的IP地址。这样在NBNS服务器停机或更改了设置(如IP地址等)的情况下，名字解析不能完成，就不能进行NetBIOS通信。当然NetBIOS计算机可以配置为使用多个NBNS服务器，以便在其中一个出现问题时使用备份的服务器。
* M-node(Mixed):为了正确解析NetBIOS 名字，最好综合使用广播和名字服务器的方式，这样的名字识别是-一个复合的过程。M-node 首先通过B-node 广播方式进行名字识别过程，当广播方式失败之后，再使用P-node方式进行查询。
* H-Node(Hybrid): H-node 模式也是一种复合模式， 它与M-node不同的地方是查
找的顺序不同。H-node 先查找NBNS名字服务器，然后再使用广播方式进行
查询。
* Windows中实际使用的名字识别方式是对标准H-node 方式的扩展，Windows 系列的计算机将首先检查缓存中的内容，然后再查看WINS 服务器，之后进行广播，然后将查找lmhosts 文件，以及通过hosts 和DNS进行查找。实际进行NetBIOS识别是一个 复杂的过程，主要就是由于NetBIOS是一个动态的名字解析
方式，每一台计算机都必须注册自身。
(2) NetBIOS 名字识别的过程
与DNS不同，NetBIOS名字使用动态方式进行管理。DNS数据是静态的，增加和删除DNS名字需要管理员手工更改配置文件。但NetBIOS要求计算机在网络上自动注册其名字，计算机停机之后占用的名字会被释放，这个过程不需要管理员干预。因为它需要额外的网络数据以完成名字登记等过程，使得它不适合像Internet这样的大型网络。
NetBIOS名字识别需要经过如下3个步骤。

1)名字注册:在NetBIOS启动时，计算机向整个网络声明占用了一个NetBIOS 名字，如果已经有其他计算机占用了这个名字，这台计算机就会收到错误信息。注册是通过
向网络广播声明信息或向NetBIOS名字服务器登记的方式来实现的。
2)名字解析: 通过广播或查询NetBIOS名字服务器来解析-一个NetBIOS 名字。此外还可以通过lmhosts文件和DNS辅助解析名字。
3)名字删除:系统关机或提供的工作站服务结束时，会删除其占用的NetBIOS名。通过NetBIOS 名字和共享的目录名，就能够定位Windows计算机上的资源。Microsoft使用UNC的形式来确定一个网络资源的位置，一个UNC以双反斜线开始，接下
来是提供资源计算机的NetBIOS名字，然后是该台计算机上提供资源的共享名，接下来就
是下面的目录和文件名。如\\ntserver\share\files。
因此使用一一个资源的命令格式如下所示:
```
C:\> net use f: \\ntserver \share
C:\> f:
F:\>
```
(3)名字服务器的工作原理
由于B-node广播会在网络.上产生大量的信息流，尤其是在网络是由多个子网构成的时候，而使用路由器本来就是要隔离广播信息，可是为了进行名字解析，就不得不转发B-node广播信息包，这就达不到缩减无用网络流量的目的。使用名字服务器进行解析就能避免这个问题，客户通过对名字服务器进行查询而非广播，信息流就不必传播到各个子网上，就能减少广播数据，减轻网络的负担，节省带宽，并且能有效地提高名字解析的速度及准确性。实际存在的Windows网络甚至很少利用名字服务器进行名字解析，这就使得这些网络名字解析存在很大问题，常常会出现不同计算机的网络邻居列表不同，根本原因就是广播方式是没有保证的，必须转向名字服务器方式才能解决名字解析问题。
当普通NetBIOS计算机和NBNS服务器进行通信时，有如下4个不同的通信过程。
* 名字注册:每台NetBIOS计算机启动时，都在名字服务器上注册。这样就保持了数据库的自动更新，并具备动态更新的特性。名字服务器将返回确认信息，以及这个名字的生存期TTL。如果客户要求的名字已经被占用了，服务器就查询占用
这个名字的客户是否还在网络上，以判断这个名字是否可以再次被使用。这种情况主要发生在Windows计算机死机后重新登记的过程中，因为此时在计算机死机之前，它在名字服务器中登记的名字还存在，如果名字服务器简单地拒绝提供名字，那么这个计算机就无法再次获得自己的名字。只有在真正发生冲突的情况
下，客户的名字注册才会失败。
* 名字更新:由于每个名字都存在一一个生存期TTL，那么当经历了这个TTL一半的时候，客户会向服务器进行更新请求，刷新服务器上的TTL设置。
* 名字释放:客户停机时会与服务器通信释放其占用的NetBIOS名字，其名字TTL
超时也会使得服务器释放这个名字。.
* 名字识别:客户可以向NBNS服务器发送查询名字的请求，进行名字解析。

在某些情况下，客户没有设置支持名字服务器，或者使用的客户软件还不支持名字服务器进行解析，可以通过设置一一个WINS代理，由它来在广播数据和查询名字服务器之间进行转换，它可以帮助客户注册并回应客户的广播查询。
#### 4.何谓 NetBEUI
NetBEUI是网络操作系统使用的NetBIOS协议的加强版本。它规范了在NetBIOS中未标准化的传输帧，还加了额外的功能。传输层驱动器经常被Microsoft LAN Manager(微
软局域网管理器)使用。NetBEUI执行OSI LLC2协议。NetBEUI 是原始的PC网络协议和IBM为LanManager(局域网管理器)服务器设计的接口。本协议稍后被微软采用，作为它们的网络
产品的标准。它规定了高层软件通过NetBIOS帧协议发送、接收信息的方法。本协议运行在标准802.2数据链协议层上。
#### 5.NetBEUI 范围
NetBIOS范围ID为建立在TCP/IP(叫做NBT)模块上的NetBIOS提供额外的命名服务。NetBIOS范围ID的主要目的是隔离单个网络上的NetBIOS 通信和那些有相同NetBIOS范围ID的节点。NetBIOS 范围ID是附加在NetBIOS名称上的字符串。两个主机上的NetBIOS范围ID必须匹配，否则两主机无法通信。NetBIOS范围ID允许计算机使用相同的计算机名，不同的范围ID。范围ID是NetBIOS名称的一部分，使名称唯一。
#### 6.NetBEUI 控制块
NetBIOS控制块(NCB)是所有NetBIOS应用程序访问NetBIOS服务时都要用到的一个程序设计结构，并且是唯一的一个。设备驱动程序也使用类似的结构。NetBIOS控制块的定义结构如下:
```c
Visual C++网络开发基本应用
typedef struct
NCB {
    BYTE ncb_ command;
    BYTE ncb retcode;
    BYTE ncb_ lsn;
    BYTE ncb num;
    DWORD ncb buffer;
    WORD ncb_ length;
    BYTE ncb callName[16];
    BYTE ncb name[16];
    BYTE ncb_ rto;
    BYTE ncb sto;
    BYTE ncb_ post;
    BYTE ncb lana num;
    BYTE ncb cmd cplt;
    BYTE ncb reserved[14];
} NCB, *PNCB;

```
### 1.1.4 小试牛刀--编程实现获取 MAC 地址
## **第 2 章 传输协议编程**
## **第 3 章 远程传输处理**
## **第 4 章 网页浏览器**
## **第 5 章 邮件传输系统**
## **第 6 章 串口通信**
## **第 7 章 网络传输**
## Linux 常用甪带系统库
Linux自带很多系统库文件，提供包括输入输出、数学运算、字符串处理、时间日期、环境控
制、内存分配、多进程并发、数据结构算法在内的很多系统函数。与自行编写代码相比，调用Linux
系统自带的库函数，开发效率、性能、可靠性更高，适用性更强。Linux 库函数符合POSIX规范(可
移植操作系统接口，Portable Operating System Interface)中的API接口标准EEE 1003，调用这些库
函数开发的应用程序可在支持POSIX规范的系统中编译运行，包括Windows系统

1. 数学函数

2. 环境控制函数
3. 字符串处理函数
4. 时间函数
5. 数据结构算法函数

## 诊断和处理 Linux 编程错误

1. 诊断和处理编译错误

如果gcc显示出错信息，通常表明程序中存在错误。在编译链接过程中报出的错误又分两种: .
-种称为错误(“error”),一般是程序中存在语法问题，常见原因包括变量无定义、标识符拼写错、
漏写标点符号、括号不匹配、存在全角中文字符、引用的函数无定义等,编译过程中只要出现“error”
错误，编译过程将很快终止，不会产生可执行程序。另-一种称为警告(“waming" )，表示程序可能
不符合某种规范，如函数调用前未做声明、程序没有换行符、缺少必要的包含文件、缺少必要的强
制类型转换等，这种错误不影响产生可执行程序，但可能导致程序运行错误。每个错误提示行一般
包括冒号(:)分隔的三个字段，分别为出错的源程序文件名、出错行号、错误描述。- 般根据错误提
示，打开源程序，找到出错行，就能发现出错原因，可据此修改程序，排除错误。有些错误不太容
易诊断

2. 处理系统调用失败

Linux系统环境下的很多库函数属于系统调用，如open、close、 write、 read、 fork， 它们的功能
是由操作系统内核实现的。很多时候，参数不正确、执行权限不够都可能导致系统调用失败，但程.
序还能继续执行，也无任何输出，只是结果不正确

其实，Linux 系统- -般通过函数的返回值来告知系统调用函数执行是否成功，执行成功时返回
值一般为0或大于0，失败时返回- 1;如果系统调用函数失败，全局整数变量ermo给出出错原因
编码，strerror(ermo)或 perror函数给出出错原因描述。因此，要想知道程序执行到何处出错了，应.
该对所有系统调用函数的返回值进行检查，并打印出错信息

但是这种在程序中加入大量错误判断语句的方法有两个问题: - -是增加太多错误检测语句，影
响程序的可读性，也会干扰编程思维;二是不规范，相同的错误显示的错误提示可能不同，同时出
错信息应该在标准错误输出中显示。
对系统调用执行情况进行检查的- -种比较好的方法是:对每个这样的系统函数(如read、write、
open、close. fork、pthread_ create 等),编写- - 个增加了错误处理功能的包装函数(eror-handling wrapper)。
我们对数十个常用的系统调用函数进行错误处理包装，统一命名成与原函数名相同、参数表相同、
返回值相同但首字母为大写的函数，这样既解决了错误检测问题，又方便使用。下面是open和read
函数的包装函数，包装函数名与原函数名相同，仅首字母变成大小，便于记忆。包装函数将返回值赋
给变量rc，如果rc<l,就表明函数调用执行失败，调用Perror函数报告错误，并终止进程

除文件IO外，我们还对进程控制、线程控制、网络编程的很多API函数进行了包装。所有包
装函数的声明保存在头文件wrapper.h中，包装函数保存在两个C程序文件wrapper.c和ptwrapper
中，并创建成库文件libwrapper.a。为解决用户在源代码中加入一大堆系统头文件带来的不便，还在
wrapper.h中包含了常用的系统头文件，这样大多数程序只需要- -条include 语句“#include
"wrappr.h""就可以了。将wrapper.h和libwrapper.a复制到工作目录下，就可以用包装函数编写程
序了。对于有些高版本的Linux发现版本，可能存在libwrapper.a库格式兼容问题，导致链接过程找
不到库中定义的函数。在这种情况下，可以用以下命令重新生成库文件libwrappera

3. 用断言检查程序状态错误

在软件的开发过程中，通过条件编译引入printf调用来调试代码是一种常见的做法，但-般不
应在发行版本中保留这些信息。然而经常会出现这样的情况:程序运行中出现的问题与不正确的假
设有关，并非代码错误。这些不正确的假设往往是被主观认为不会发生的事件。例如，人们在编写
函数时，会认为它的输入参数应该处在-一个确定的范围内，但万-传递了不正确的数据，就可能造
成整个系统运行不正常。
系统的内部逻辑需要确认没有错误。针对这种情况，XOpen提供了assert 宏，它的作用是测试
某个假设是否成立，如果不成立，就停止程序的运行

assert宏对表达式执行求值，如果结果为false，就往标准错误写-一些诊断信息，然后调用abort
函数以结束程序的运行。
头文件assert.h
中定义的宏受NDEBUG的影响。如果程序在处理这个头文件时已经定义了
NDEBUG,就不定义assert宏。这意味着可以在编译命令中使用_DNDEBUG关闭断言功能，也可
以把下面这条语句加到每个源文件中来禁止断言功能，但这条语句必须放在#include<assert.h>语句
之前

4. 用GDB/ddd 调试器诊断运行错误

Limux环境提供了GDB(GNU project debugger)调试器，以帮助诊断在程序运行阶段出现的逻辑
错误。在GDB调试器中，程序员可随时启动程序、设置断点、暂停程序的执行、随时检查变量的
值是否正确、逐步缩小出错范围、最后锁定出错行并排除错误。
GDB可以对使用C、C++、Ada、 Pascal等不同语言编写的程序进行调试，可本地调试也可远
程调试，支持所有的Linux版本和大部分UNIX平台，甚至还支持Windows平台

## 命令行参数和环境变量的读取方法

## ## make 工具

**引入 make 工具的原因**

在编写大型程序时，会有很多源程序,这些源程序如果都由人工维护,将会十分烦琐。make工
具可以帮助我们管理和维护所开发项目的源代码，使这些例行工作自动化。make 是Linux 提供的
一个工具，可以控制从程序源文件中生成的可执行代码的过程。make工具根据makefile文件的内
容构建程序，makefile 文件列出了每一- 个非源程序文件以及如何从其他文件构造这些文件的命令。
当编写程序时，应当为其编写-一个 makefile文件，利用make工具构建及安装程序，以为程序的安
装及维护提供便利。现在，make 已经成为软件项目中不可或缺的工具，在编写Java 程序时使用的
ant工具与make工具的作用相似

虽然可通过一.条编译命令“gcc -o prog prog.c
prol.c pro2.c" 将上述项目编译成可执行
程序，但对于由数十、数百、数千个程序源文件构成的软件系统项目，若每次对某个程序源文件做
细微修改后，都要将所有程序源文件重新编译一次，命令输入将非常烦琐，编译过程也非常耗时;
Linux的make工具可以管理多个文件模块，它提供一种灵活机制来实施大型软件项目管理，高效地
管理程序的编译过程。make 机制依赖于make命令和makefile文件来对项目的编译过程进行管理，
makefile文件描述程序源文件之间的相互依赖关系，make命令根据makefile文件给出的规则，执行
编译操作管理。系统中的部分文件改变时，make工具根据这些关系仅执行必要的编译操作。如果软
件包括几十个程序源文件和多个可执行文件，make 工具将特别有用。
makefile主要由一系列规则构成，每条规则由“make目标”和目标后的命令序列构成。makefile
规则有显式规则与隐含规则两种，makefile 文件还包括变量定义、注释等

**用 makefile 描述源文件间的依赖关系**

可用类似于邻接表的方法来表示项目的依赖关系:每个目标文件节点与其依赖关系节点间的关
系用一条规则表示，由依赖关系行和命令行构成，依赖关系行的格式为“目标文件列表:依赖文件列
表”，其下是从依赖文件列表生成目标文件的命令序列。由于所有规则保存在makefile文件中，为
区分依赖关系行与命令行,规定依赖关系行从第- 列开始写,命令行的第-一个字符必须是<TAB>键。
这样每条规则结构如下

**引入伪目标以增强 makefile 功能**

在大型软件开发项目管理中，有时需要清除所有可执行文件和目标文件，以便对全部源程序重
做一次完整编译。这时可通过增加一条clean规则来实现，比如上面实例中的clean规则可写成

**用变量优化 makefile 文件**

makefile
文件中很多目标文件、源程序文件的名字，以及编译程序gcc的名字在多个地方重复
出现，若- -处写错，都将导致出错，同时给文件更名带来不便，采用makefile变量可解决这个问题。
makefile中的变量定义语法为: VARNAME- sting。用户自定义变量名一般大写，变量值都是字符
串，不需要指定类型，变量定义行顶格写，中间无分隔符“:”，以便与规则的依赖关系行区分。
引用VARNAME变量值的方法是$ {VARNAME}，make 解释规则时，VARNAME 在等式右端展开
为定义它的字符串

**用预定义变量和隐含规则简化 makefile 文件**

make工具还定义了很多预定义变量来表示-条规则的依赖关系行中已经出现过的名称,在规则
的命令行部分只需要引用这些预定义变量，目标文件名称仅出现一次, 可避免拼写错误，在makefile
文件中可使用的预定义变量如下
表3-11预定义变量

| 变量 | 变量含义                                                   |
| ---- | ---------------------------------------------------------- |
| $@   | 表示规则中目标文件的名称                                   |
| $<   | 依赖列表中的第一个文件名                                   |
| $?   | 比目标文件更新的以空格分隔的依赖文件                       |
| $^   | 以空格分隔的所有依赖文件，重复的依赖文件会被合并           |
| $*   | 在显式规则下，表示文件名称的主要部分(即不包括文件的扩展名) |

```makefile
OBJS=pro1.o pro2.o prog.o
CC-gcc
prog: $ {OBJS}
	${CC} -o $@ $^
pro1.o: prol.c
	${CC} -c $< -o $@
pro2.0: pro2.c
	${CC} -c $< -o $@
prog.o: prog.c lib.h
	${CC} -c $< -o $@
.PHONY:clean
clean:
	rm *.o prog
```




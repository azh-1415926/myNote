## 输入输出与文件系统

文件系统是操作系统中负责存储和管理信息的模块，它以一致的方式管理用户和系统信息的存
储、检索、更新、共享和保护，并为用户提供一整套方便有效的文件使用和操作方法。对计算机类
专业学生来说，学习文件系统的基本工作原理，掌握文件和I/O编程，对未来开发出效率高、可靠
性好的软件能带来帮助，同时也是理解计算机系统工作原理，未来从事相关研究与应用优化的基础。
接下来主要讲解文件系统层次结构、系统I/O、内核文件IO数据结构、文件组织、文件物理结构等

**文件系统层次结构**

简介

一般来说，我们要处理的数据信息都存在于文件中，处理结果也保存于文件中，而文件数据保
存在外存中。磁盘是最常见的外存，它属于存储设备，用户不能像操作内存数据结构一样读写磁盘。
磁盘有两个特点:一是磁盘属 于外部设备，外设编程难度极大;二是内存与磁盘之间只能以数据块
而非字节为单位来传递数据，数据块大小通常为磁盘块大小，通常为512B- 4KB。实际上文件读写
过程是非常复杂的。
为实现对磁盘的高效便捷操作，操作系统通过文件系统模块来存储、定位、提取数据。为驾驭
系统复杂性，通常将文件系统设计成多层结构，如图4-1所示。每层都利用较低层的功能创建新的
功能来为更高层服务

IO控制(I/O contro])为最底层，由设备驱动程序和中断处理程序组成，实现内存与磁盘之间的
信息传输。设备驱动程序作为翻译器，将上层给出的命令，翻译成底层硬件能执行的动作或指令，
实现数据读写，如"retrieve block 123"表示上层需要读取123号磁盘块的内容。
基本文件系统(basic file system)向合适的设备驱动程序发送对磁盘上的物理块进行读写的命令。
磁盘块的地址可用一个四元组表示， 如(驱动器1,柱面(cylinder)73， 磁道(rack)3， 扇区(sector)10)。
文件组织模块(file organization module)涉及文件系统结构、文件格式和文件位置，将逻辑地址
或逻辑块号转换成基本文件系统所用的物理地址(磁盘块号或称盘块号)。每个文件的逻辑块按从0
或1到N的顺序编号，一般逻辑块号与物理块号是不同的，因此需要通过翻译来定位盘块号。文件
组织模块也包括空闲空间管理器，用来跟踪未分配的盘块并分配给文件使用

最后，逻辑文件系统(ogic file system)管理元数据。元数据包括文件系统的结构数据，而不包括
实际数据(或文件内容)。逻辑文件系统根据给定文件名来管理目录结构，使用文件控制块(File Conltol
Block, FCB)来维护文件结构。文件控制块包含文件的信息，如拥有者、权限、文件内容的位置。
逻辑文件系统也负责保护和安全。
文件系统接口是用户或应用程序操作文件的方法和手段，通常有两种类型的接口:一类是命令
接口，使用户可通过终端命令来操作文件，如mkdir、qp、 mv、cat; 另一类是程序接口，支持应用
程序操作文件，如创建文件的系统调用create、 打开文件的系统调用open。Linux环境下的文件系统
编程接口又称文件系统调用或UNIX IO,主要包括open、close、 lseek、 read、 write 等系统调用函
数

**文件 I/O 库函数**

由于UNIX IO提供的API函数不够丰富，在某些场景下直接用UNIX IO库函数编程，显得不
够方便、灵活。因此，人们基于UNIX IO设计了多套可方便编程、使I/O操作高效执行的I/O库。
这里介绍两个这样的IO库:标准IO库和RIO库。
标准I/O库是C语言规范ANSI C支持的文件操作函数I/O库。它将-一个打开的文件模型化为
-一个流，流是一个指向FILE类型的结构的指针。每个程序开始时都有三个打开流stdin、 stdout 和
stderr,分别对应标准输入、标准输出和标准错误输出

标准IO库包括打开和关闭文件的函数(fopen和fclose)、读写数据块的函数(fread和fwrite)、读
写字符串的函数(fgets和fputs),以及格式化I/O函数(scanf和print)，使用用户级缓冲区，读写效率
高。一般支持C语言的环境都支持标准I/O库，包括Linux C和Windows C环境。
RIO库是由Randy Bryant为弥补系统IO在读文本行和处理不足值时存在的缺陷而设计的。RIO
库在用户态设置缓冲区，自动处理read/write 函数的不足值，支持以文本行为单位读取数据，给网
络应用编程开发带来极大便利

## 系统 I/O 概念与文件操作编程

**UNIX I/O**

一个UNIX文件就是--个包含m个字节的序列:.
Bo, B..... Be.... Bm1
所有的IO设备，如网络、磁盘和终端，都被模型化为文件，而所有的输入和输出都被当作对
相应文件的读写来执行。这种将设备优雅地映射为文件的方式，允许UNIX内核引出一个简单、低
级的I/O操作应用接口，称为UNIX IO，又称系统IO。它以一致的方式来执行所有输入和输出，
UNIX IO包括以下几个系统调用函数:

* 文件打开函数(open)。应用程序通过调用open函数来要求内核打开相应的文件，宣告想要访问IO设备或文件。内核返回一个称为文件描述符的非负整数，用于在后续读写操作中标识这个文件。内核记录有关这个打开文件的所有信息，应用程序只需要记住这个文件描述符。每个进程开始时都有三个打开的文件:标准输入(文件描述符为0)、标准输出(文件描述符为l)和标准错误输出(文件描述符为2)。头文件<umistdh>定义了三个宏STDIN FLENO、STDOUT FLENO和STDERR FILENO,用来代替文件描述符的值0、1. 2
* 改变当前的文件位置函数(seek)。每个打开文件都保持着一个读写位置， 其值k是距离文件起始位置的字节偏移量，新打开文件的读写位置为0，随读写操作移动，也可通过调用函数lseek移动到任何位置
* 文件读 写函数(read/write)。读操作就是从文件当前读写位置k传递n(n>0)个字节到内存，文件读写指针向前移动n个字节，增加到k+n。给定一一个大小为m字节的文件，当k>m时，执行读操作会触发- -个称为EOF(End Of File)的条件，应用程序可通过检测这个条件来判断是否到达文件末尾，但在文件结尾并没有明确的“EOF”符号
* 文件关闭函数(close)。当应用程序完成对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个文件描述符恢复到可用的描述符池中。无论-一个进程因为何种原因终止，内核都会关闭所有打开文件并释放它们的存储器资源

UNIX IO对文本文件和二进制文件的读写没有任何区别，因为它在实际读写数据时，全然不管
数据内容，每次在内存和文件之间传送指定数量的字节

**文件打开和关闭函数**

1. 文件打开函数

   ```c
   #include<sys/types.h>
   #include<sys/stat.h>
   #include<fcntl.h>
   int fd=open(char* filename,int flags,mode_t mode);
   ```

   open 函数将 filename 转换为一个文件描述符，并且返回具体的值。返回的文件描述符总是进程中当前可用的最小空闲描述符。C 程序在执行任何读写操作前都需要先执行open函数以打开文件，后面的文件读写操作都用返回的文件描述符来指明要操作的文件

   1. flags

      * O_RDONLY 只读
      * O_WRONLY 只写，如果文件非空，写入内容以替换要写入位置的数据
      * O_RDWR 可读可写，如果文件非空，写入内容以替换要写入位置的数据
      * 示例，以只读方式打开文件 foo.txt
        * fd=open("foo.txt",O_RRDONLY,0)
      * 如果打开方式包括写操作，flags 参数还可以通过位或操作增加以下标志中的一个或多个
        * O_CREAT 如果文件不存在，就创建一个新的文件
        * O_TRUNC 如果文件已经存在，就截断它
        * O_APPEND 以添加方式打开文件，在每次写操作前，设置文件读写指针到文件的结尾处

   2. mode

      * 调用 open 函数打开已存在文件时，参数 mode 一般设置为 0，若打开一个不存在的文件，open 函数创建新的文件，这时候需要通过 mode 参数指定新文件的访问权限位，否则文件权限全为 0，mode 的参数可以是一个 3 位的八进制数值，也可按照以下符号位或而成

        * | 权限    | 八进制表示 |
          | ------- | ---------- |
          | S_IRUSR | 0400       |
          | S_IWUSR | 0200       |
          | S_IXUSR | 0100       |
          | S_IRGRP | 0040       |
          | S_IWGRP | 0020       |
          | S_IXGRP | 0010       |
          | S_IROTH | 0004       |
          | S_IWOTH | 0002       |
          | S_IXOTH | 0001       |

        * 新建文件的权限还会受新建文件权限掩码 umask 影响，umask 的默认值为 0022，指定新建文件的权限会与 umask 的反码做与运算，故此时最高权限为 0755，umask 指定的权限位会被去除，因此表示同组用户和其他用户都没有写操作，这样可以保护用户创建的文件免遭他人有意或无意修改、删除

2. 文件关闭函数

   ```c
   #include<unistd.h>
   int close(int fd);
   ```

**文件读写编程与读写性能改进方法**

应用程序时通过分别调用 read 和 write 函数来执行输入和输出的

函数原型

```c
#include<unistd.h>
ssize_t read(int fd,void *buf,size_t n);
/*
返回值
	成功，则读出的字节数
	若遇到 EOF ，则为 0
	若出错，为 -1
*/
ssize_t write(int fd,const void *buf,size_t n);
/*
返回值
	若成功，则为写入的字节数
	若出错，为 -1
*/
```

复制文件的示例

```c
/* fcopy1.c代码*/
#include "wrapper.h"
int mainO
{
    char C;
    int in,out;
    in = open("fle.in"，O RDONLY, 0);
    out = open("file .out", O_ WRONLY|O_ CREAT|O _TRUNC,0666 );
    while(read(in,&c,1)== 1)
    	write(out，&c,1 );
    close(in);
    close(out);
    exit (0);
}
```

执行

```shell
# 之前我们将大部分常用的头文件加到了库 wrapper 中
$ gcc -o fcopy1 fcopy1.c -L. -lwrapper
# 用 dd 命令以 /dev/zero 为输入设备，创建所有字节初始化为0的二进制文件 file.in，每次复制一块，块大小为 bs=1024B，块数为 count=2048，输入数据文件大小为 2MB
$ dd if=/dev/zero of=file.in bs=1024 count=2048
$ ls -l file.in
-rW-rW-r-- 1 can can 2097152 Mar 28 02:58 file.in
$ ./fcopy1
# 用 diff 命令检查源文件 file.in、目的文件 file.out 的内容是否完全相同
$ diff file.in file.out
# 该命令无任何输出，表明执行正确，file.out 就是 file.in 的副本
$ time ./fcopy1
real	0m9.27s
user	0m0.98s
sys		0m7.77s
# 用 time 命令执行 ./fcopy1，测量程序的执行时间
# 测得结果中
# 	user 表示在用户态运行花 0.98 秒
# 	sys 表示在核心态运行花 7.77 秒
# 	real 表示实际耗时 8.27 秒
```

二进制文件的内容无法用 more、cat 等命令查看，用 od 命令显示其字节值又不方便。所以我们
用 diff (ifference)命令检查源文件 file.in、 目的文件 file.out 的内容是否完全相同，进而检验 fcopyl
是否正确执行

每复制-一个字符都需要调用一次 read 函数和一次 wite 函数，共需要执行1024*2048次read和write函数调用，数据复制效率低应该是程序耗时的原因。要提高程序执行效率，应大幅减少read/write调用次数

**文件定位与文件内容随机读取**

lseek 系统调用函数调整文件读写指针的位置，设置文件的下-一个读写位置，读写指针既可被设置为文件中的某个绝对位置，也可以设置为相对于当前位置或文件末尾的某个位置

函数原型

```c
#include<unistd.h>
#include<sys/types.h>
off_set lseek(int fd,off_t offset,int whence);
/*
返回值
	成功时返回调整后的读写位置
	失败时返回 -1
*/
```

* offset 参数指定位置
* whence 取值如下
  * SEEK_SET 从文件起始位置移动，结果读写指针位置为 offset
  * SEEK_CUR 从当前位置移动，结果为当前读写指针值 +offset
  * SEEK_END  从文件末尾移动，结果为文件长度 +offset
* 若位置计算结果小于 0，则 lseek 执行失败，读写指针不移动，函数返回值为 -1
* 若位置计算结果超过文件长度，则对文件大小按指针值进行扩展
* 正确执行时，lseek 返回从头文件到文件指针被设置处的字节偏移值，失败时返回 -1
* 参数 offset 的类型时一种与具体实现有关的整数类型，定义在头文件 sys/types.h

**任何类型数据的文件读写**

read、 write 函数在内存和文件之间传输一个数据块，这个数据块在内存中的地址为 buf ，在文件中的位置为pos。这个数据块位于内存中时，其内容可以是任何类型，如整型、浮点型、字符串、数组、结构体、联合体，因此，UNIX IO 可以实现任意类型数据的文件读写功能
假设我们用 `T var` 定义了一个类型为T的变量 var ，则该变量所在内存块的地址为 &var ，可将其转换成 `void *` 类型，该内存块的长度为 `sizeof(T)`，所以将变量 var 的值写入文件 fd 当前位置的 write 函数调用 `write(fd,(void*)&var,sizeof(T))`。同样，将保存在文件当前位置的变量 var 的值读回内存的 read 函数调用应为 `read(fd.(void*)&v, sizef(T)` 比如，要将一个浮点数变量(loat f=123.45677)的值写入文件 fd，则   wite 函数调用可以是 `write(fd,(void*)&f, sizeof(float))` ，要从文件 fd 的当前读写位置读出一个整型值赋给整型变量 (int k)， 则read函数调用可写成 `read(fd, (void) &k, sizeof(k))`
很多时候，我们需要将一个元素类型为T的数组var(假定定义为T var[N)写入文件，这可通过每次写入一个元素的循环来实现

**用文件读写函数操作设备**

Linux系统将设备看成文件，可以用UNIX IO函数打开设备以获得文件描述符，然后通过文件描述符从设备读数据或向设备写数据。一个典型的例子就是读写每个进程专用的标准输入设备(键盘输入)、标准输出设备(终端窗口)、标准错误输出设备(终端窗口)，这三个设备文件已经在程序启动时由系统打开，文件描述符分别为0、1. 2，相应的宏为STDIN FLENO、STDOUT FILENO、STDERR_ FLENO

```c
/* fcopy3.c源码*/
#include "wrapper.h"
int main(void)
{
    char C;
    while((read(STDIN_FILENO,&c,1))==1);
    write(STDOUT_ FILENO,&c,1);
    exit(0);
}
```

该程序将从标准输入(文件描述符为0)键入的字符串复制到标准输出(文件描述符为1)，用户输入一行完整信息并键入回车键后，把输入文本行提交系统，程序开始读取操作，每次复制一个字符，结果就是输入一行，输出一行

其实，Linux 系统的每个命令终端窗口都有设备文件名，打开两个命令终端窗口，可用 tty 命令查看各自的设备名，假定分别为 /dev/pts/0 和 /dev/pts/1 ,并用 ls 命令核实 /dev/ 目录下确实存在这两个设备文件(当然可能还包含其他终端设备文件)

## 内核文件 I/O 数据结构及应用

Linux系统的文件共享、重定向、管道都是通过对打开文件内核数据结构的操作来实现的。如果不清楚内核是如何表示打开文件的，这些概念和原理会很难理解，也就很难进行相关的应用编程。内核用三个相关的数据结构来表示打开的文件。
(1) v-node表 (v-node table)
Linux 将打开文件的属性信息保存在索引节点对象(inode object)中， 索引节点对象又称为 v-node。文件属性信息包括文件名、文件大小、访问权限、修改时间、文件数据盘块地址等，在磁盘上保存在文件控制块 (FCB, File Control Block) 中。 Linux 系统的文件控制块称为索引节点，stat 结构体类型详细列出了所有文件属性，其中的st_ mode 成员包括文件类型和访问权限，st_ size 成员为文件大小。由于v-node可能被多个其他对象引用，因此需要添加打开次数字段(i count)。系统的所有v-node构成-一个 v -node表
(2)文件表 (file table)
Linux 将打开文件信息存储在文件对象 (file object) 中，又称file 结构，主要成员包括打开方式 (f_ mode)、读写指针 (f_pos)、引用计数 (f_count) 三个字段，其中引用计数记录指向结构体的指针数。对一一个文件执行一次打开操作，就会创建一个文件对象， 系统的所有文件对象组成一个文件表
(3)描述符表 (descriptor table)
每个进程都有一个独立的文件描述符表 (descriptortable)，数据类型定义是 `structfile *fd array[NR_ OPEN_DEFAULT]`, 是指向文件对象的指针数组。UNIX IO用描述表项的索引号作为 open系统调用函数的返回值，称为文件描述符 (descriptor)。其后的文件操作都使用文件描述符来定位文件对象，进而定位 v-node 对象来获取文件属性

**文件描述符和标准输入输出**

描述符表最多有 255 个表项，每个表项保存一个指向文件对象的指针，而文件对象又有一一个指向 v-node 对象的指针。程序开始时，文件描述符 0、1、2 分别被标准输入 (stdin)、标准输出 (stdout) 和标准错误输出 (stderr) 占用，在进程启动前由系统设置好，它们指向的文件对象分别指向键盘设备和监视器设备(或终端窗口)的 v-node 对象。UNIX 系统的 scanf、getchar、 gets 等系统函数实际上是一种特殊的读文件操作，它们从文件描述符0读入数据，由于描述符 0(stdin) 关联了键盘设备 v-node，因此这些函数就从键盘读入数据。同样, printf、putchar、puts函数是一种特殊的写文件操作,它们将输出写入描述符 1(stdout)，而程序产生的错误输出被系统送往描述符 2(stderr)。 由于描述符 1、 2 最终都关联到监视器设备的 v-node，因此程序产生的正常输出和出错信息都在监视器(终端窗口)中显示。程序刚启动时，从 3 开始的文件描述符全部空闲，函数调用 open 的返回值从 3 开始往后递增

**文件打开过程**

当程序中执行 open 函数打开文件时，系统首先检查文件的 v_ node 是否存在，若不存在，则首先为其创建 v_ node，将文件的属性从外存读入 v-node，然后，创建其文件对象，设置读写方式、读写位置、v-node 指针，将访问计数器置为 1，最后，在进程的描述符表中找到索引号最小的空闲表项，在其中填入文件对象的指针，返回描述符表项的索引号。程序在启动时，文件描述符0、1、2已经分配给 stdin、 stdout、 stderr 三台设备，从 3 以后的文件描述符为空闲

**内核文件 I/O 数据结构共享原理**

Linux 系统中，由于每次调用 open 函数都会创建一个新的文件对象和一个新的描述符，但同一文件仅有一个 v-node，因此，一个进程对一个文件执行多次 open 函数，比如执行两次 fd= open("f1",...)，就会创建两个文件对象、两个描述符和一个 v-node，由于两个文件对象指向同一 v-node，v-node 引用计数变成 2。这样，当调用open 函数去打开一个已有 v-node节点的文件时，不创建新的 v-node，仅将文件的 v-node 引用计数 i_count 加1。不难获知，当我们调用 close 函数关闭某个文件时，如果 v-node 引用计数大于 1，只需要将计数值减1,仅当关闭 v-node 的 i_count 成员为1的文件时，才销毁其 v-node 对象

Linux系统中，子进程可以继承父进程所有已经打开的文件。如果父进程创建一个 子进程，子进程会获得父进程描述符表的一个副本。由于父子进程共享相同的打开文件表，在文件表中，原来由父进程打开的每个文件，都会有两个文件描述符指向它，一个来自父进程，为一个来自子进程，所以文件表中的引用计数变成了 2，不难获知，当我们调用 close 函数关闭某个文件时，如果其文件对象的引用计数大于 1，只需要将计数值减 1,仅当关闭文件对象引用计数为1的文件时，才销毁其文件对象

**dup 和 I/O 重定向**

